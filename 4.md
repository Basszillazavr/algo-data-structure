# Lecture 5: Foundational Algorithm Patterns üõ†Ô∏è

**Learning Objectives:** By the end of this lecture, students will be able to:
* Identify problems suited for the **Two Pointers** pattern.
* Understand how to use the **Sliding Window** to optimize array/string problems.
* Apply **Greedy Algorithms** to find local optima.
* Grasp the concepts of **Backtracking** for combinatorial search problems.

***

## **1. Two Pointers Pattern** üîÄ

This pattern uses two pointers to iterate through a data structure (usually a sorted array or string) from different positions to meet a specific condition. It often reduces time complexity from $O(n^2)$ to **$O(n)$**.

### **Mechanism & Examples**

| Pattern Type | Mechanism | Example Problem |
| :--- | :--- | :--- |
| **Opposite Direction** | Pointers start at opposite ends (`left` at 0, `right` at $n-1$) and move inward. | **Finding Target Sum in a Sorted Array:** Array: `[1, 2, 5, 8, 10]`, Target = 10. Pointers move until `2` and `8` are found. |
| **Same Direction** | Pointers start at or near the beginning and move in the same direction, maintaining a specific relationship. | **Removing Duplicates from a Sorted Array:** Use one pointer (`i`) to track the last unique element and a second pointer (`j`) to iterate through the entire array. |

---

## **2. Sliding Window Pattern** üñºÔ∏è

The Sliding Window is a technique used on linear data structures (arrays/strings) to maintain a sub-array or sub-string (the "window") whose size can be fixed or variable. It's used to solve problems involving finding the shortest, longest, or a specific sub-sequence.

### **Mechanism & Example**

1.  **Expand:** A `end` pointer moves to the right to include new elements and expand the window.
2.  **Contract (Validate):** If a condition is met (or violated), a `start` pointer moves to the right to shrink the window and find an optimal result (e.g., the shortest valid window).

* **Example: Longest Substring Without Repeating Characters**
    * String: `"abcabcbb"`
    * Window starts at `a`. **Expand** to `abc`. (Valid). Length = 3.
    * Next is `a`. Duplicate found! **Contract**: Move `start` past the first `a`. Window becomes `bca`.
    * The window "slides" to ensure it always holds valid candidates, eliminating redundant checks.

---

## **3. Greedy Algorithms** ü•á

A **Greedy Algorithm** builds a solution piece by piece, always choosing the locally optimal option‚Äîthe one that seems best at the current moment‚Äîin the hope of reaching a globally optimal solution.

### **Mechanism & Example**

* **Core Principle:** *Optimal Substructure* and the *Greedy Choice Property* (A globally optimal solution can be achieved by making a sequence of locally optimal choices).
* **Application:** Problems where making the most obvious, immediate choice doesn't hurt future steps.
* **Example: Activity Selection Problem**
    * Goal: Select the maximum number of non-overlapping activities from a list.
    * **Greedy Choice:** Always select the activity that finishes **earliest**.
    * *Why?* By choosing the earliest-finishing activity, you maximize the remaining time available for subsequent activities, ensuring the highest count overall.

---

## **4. Backtracking** üå≤

**Backtracking** is an algorithmic technique for solving problems recursively by trying to build a solution incrementally. If a partial solution is found to be invalid or non-optimal, the algorithm **backtracks** (removes the choice) and tries the next available option.

### **Mechanism**

1.  **Choice:** Select a potential candidate to add to the current partial solution.
2.  **Constraint Check:** Verify if the choice violates any problem constraints.
3.  **Recursion:** If valid, proceed to the next step (recursive call).
4.  **Backtrack:** If the recursive call fails to find a solution, undo the choice (clean up the state) and try the next candidate.

### **Detailed Example: Solving Sudoku** üìù

The Sudoku puzzle is the canonical example of Backtracking. The goal is to place numbers 1-9 in empty cells (`.`) such that they follow three constraints: unique in row, unique in column, and unique in $3 \times 3$ box.

**The Backtracking Process:**

1.  **Find an Empty Cell:** Scan the grid for the next unassigned cell (the current *Choice Point*).
2.  **Try Candidates:** Loop through numbers 1 through 9.
3.  **Constraint Check:** For each number $k$, check if $k$ is valid to place in that cell (i.e., it doesn't conflict with the row, column, or $3 \times 3$ box).
4.  **Recursion:**
    * If $k$ is **valid**, place $k$ in the cell and make a recursive call to solve the *next* empty cell.
    * If the recursive call **returns true** (a solution was found), great! Return true all the way up.
5.  **Backtrack:**
    * If the recursive call **returns false** (no solution could be found with $k$ in this cell), then **un-assign** the cell (set it back to `.`) and try the next number (i.e., $k+1$).
6.  **Termination:** If all numbers 1-9 have been tried in the cell and none led to a solution, return false. This triggers backtracking up to the previous choice point. 
